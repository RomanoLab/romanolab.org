<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <meta name="author" content="Joseph D. Romano" />
        
        
        <title>Romano Lab</title>

        <style>
        body {
    max-width: 800px;
    padding-top: 36px;
    padding-left: 48px;
}

@font-face {
    font-family: "Computer Modern";
    src: url('http://mirrors.ctan.org/fonts/cm-unicode/fonts/otf/cmunss.otf');
}
@font-face {
    font-family: "Computer Modern";
    src: url('http://mirrors.ctan.org/fonts/cm-unicode/fonts/otf/cmunsx.otf');
    font-weight: bold;
}
@font-face {
    font-family: "Computer Modern";
    src: url('http://mirrors.ctan.org/fonts/cm-unicode/fonts/otf/cmunsi.otf');
    font-style: italic, oblique;
}
@font-face {
    font-family: "Computer Modern";
    src: url('http://mirrors.ctan.org/fonts/cm-unicode/fonts/otf/cmunbxo.otf');
    font-weight: bold;
    font-style: italic, oblique;
}

body {
    /* font-family: "Computer Modern", sans-serif; */
    font-family: sans-serif;
}

h4 {
    margin-bottom: 8pt;
}
        </style>
    </head>
    <body>
        <main>
            
    
    <h1>Romano Lab</h1>
    <h2>Knowledge-driven biomedical data science</h2>
    <canvas></canvas>
    <p>
        The Romano Lab is a new biomedical research team launching in 2023 at the <a href="https://www.upenn.edu">University of Pennsylvania's</a> <a href="https://www.med.upenn.edu">Perelman School of Medicine</a>. 
    </p>
    <p>
        We focus on using <i>structured biomedical knowledge</i> to answer interesting questions in biomedicine. We're particularly interested in applications to environmental toxicology. Some of our favorite methods are multimodal graph machine learning and applied ontology inference.
    </p>
    <p>
        Peripheral areas of interest include:
    </p>
    <ul>
        <li>Natural product drug discovery</li>
        <li>Genetic programming / evolutionary algorithms</li>
    </ul>
    <hr/>
    <h3>Personnel</h3>
    Check <a href="personnel.html">here</a> for current and past members of the lab.
    <hr/>
    <h3>Open Positions</h3>
    <p>
        We are <a href="positions.html">hiring</a> for multiple positions!
    </p>


        </main>
        <script>
            /**
 * graph.js
 * Copyright (c) 2022 by Joseph D. Romano
 * 
 * Simple routines for drawing random graphs
 */


// Global variables

const globals = {
    'nodeRadius': 4,
    'nodeSpacing': 25,
    'edgeWidth': 2,
    'edgeColor': '#808080'
};

const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d');

const colors = [
    '#e91e63',
    '#fa750f',
    '#ffeb3b',
    '#4caf50',
    '#02b3e4',
    '#c341d8'
]; 


// Data structures

class Node {
    constructor(x, y) {
        this.x = x;
        this.y = y;

        this.left   = this.x - globals.nodeSpacing / 2 + globals.nodeRadius;
        this.top    = this.y - globals.nodeSpacing / 2 + globals.nodeRadius;
        this.right  = this.x + globals.nodeSpacing / 2 - globals.nodeRadius;
        this.bottom = this.y + globals.nodeSpacing / 2 - globals.nodeRadius;

        this.abs_x = this.left + (this.right - this.left) * Math.random();
        this.abs_y = this.top + (this.bottom - this.top) * Math.random();

        this.color = colors[Math.floor(Math.random() * colors.length)];
    }

    drawNode() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.abs_x, this.abs_y, globals.nodeRadius, 0, 2 * Math.PI);
        ctx.fill();
    }

}


class Edge {
    constructor(startNode, endNode) {
        console.log(startNode);
        console.log(endNode);
        
        this.startNode = startNode;
        this.endNode = endNode;

        this.x1 = this.startNode.abs_x;
        this.x2 = this.endNode.abs_x;

        this.y1 = this.startNode.abs_y;
        this.y2 = this.endNode.abs_y;
    }

    drawEdge() {
        console.log("DRAWING EDGE: ", this);
        ctx.strokeStyle = globals.edgeColor;
        ctx.edgeWidth = globals.edgeWidth;
        ctx.beginPath();
        ctx.moveTo(this.x1, this.y1);
        ctx.moveTo(this.x2, this.y2);
        ctx.stroke();
    }
}


// Drawing subroutines
function drawNodes(nodes) {
    nodes.forEach(n => n.drawNode());
}

function drawEdges(nodes, adjacency_list) {
    let edges = [];
    
    adjacency_list.forEach(al => {
        edges.push(new Edge(nodes[al[0]], nodes[al[1]]))
    });

    console.log(edges);

    edges.forEach(e => e.drawEdge());
}

function drawGraph(coords, adjacencies) {
    // Draw nodes
    if (coords) {
        let nodes = Array();

        coords.forEach(n => {
            nodes.push(new Node(n[0], n[1]));
        });
        
        drawNodes(nodes);
        drawEdges(nodes, adjacencies);
                
    } else {
        // draw random nodes
        console.log("Shouldn't be printing this yet!!");
    }
}


// Draw a random graph
let node_coords = [
    [30, 85],
    [150, 60],
    [210, 100]
];
let adjacencies = [
    [0, 2],
    [0, 1]
];

function start() {
    drawGraph(node_coords, adjacencies);
}

window.setTimeout(start, 1000);
        </script>
    </body>
</html>