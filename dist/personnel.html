<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <meta name="author" content="Joseph D. Romano" />
        
        
        <title>Lab Members â€” Romano Lab</title>

        <style>
        @font-face {
    font-family: "Computer Modern";
    src: url('http://mirrors.ctan.org/fonts/cm-unicode/fonts/otf/cmunss.otf');
}
@font-face {
    font-family: "Computer Modern";
    src: url('http://mirrors.ctan.org/fonts/cm-unicode/fonts/otf/cmunsx.otf');
    font-weight: bold;
}
@font-face {
    font-family: "Computer Modern";
    src: url('http://mirrors.ctan.org/fonts/cm-unicode/fonts/otf/cmunsi.otf');
    font-style: italic, oblique;
}
@font-face {
    font-family: "Computer Modern";
    src: url('http://mirrors.ctan.org/fonts/cm-unicode/fonts/otf/cmunbxo.otf');
    font-weight: bold;
    font-style: italic, oblique;
}

html {
    position: relative;
    min-height: 100%;
}

body {
    max-width: 800px;
    padding-top: 36px;
    padding-left: 48px;
    font-family: -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif;
    margin-bottom: 80px;
}

h4 {
    margin-bottom: 8pt;
}

.headshot {
    height: 200px;
    width: 200px;
    float: left;
}

.headshot-img {
    width: 100%;
}

.bio {
    margin-left: 216px;
}

.titles p {
    font-size: 0.9em;
    margin-block-start: 0;
    margin-block-end: 2px;
}

#bottom-footer {
    position: absolute;
    /* padding-left: 48px; */
    bottom: 0;
    height: 80px;

}


/* Collapsible info displays */
.wrap-collapsible {
    margin-left: 12px;
}
input[type='checkbox'] {
    display: none;
}
.collapsible-toggle {
    display: block;

    font-weight: bold;
    
    /* color: #A77B0E;
    background: #FAE042; */

    cursor: pointer;

    border-radius: 4px;

    transition: all 0.25s ease-out;
}
.collapsible-toggle:hover {
    color: #7C5A0B;
}
.collapsible-toggle::before {
    content: ' ';
    display: inline-block;

    border-top: 5px solid transparent;
    border-bottom: 5px solid transparent;
    border-left: 5px solid currentColor;

    vertical-align: middle;
    margin-right: .7rem;
    transform: translateY(-2px);

    transition: transform .2s ease-out;
}
.collapsible-content .content-inner {
    background: rgba(250, 224, 66, .2);
    border-bottom: 1px solid rgba(250, 224, 66, .45);

    border-bottom-left-radius: 7px;
    border-bottom-right-radius: 7px;
    padding: .5rem 1rem;
}
.collapsible-content {
    max-height: 0px;
    overflow: hidden;

    transition: max-height .25s ease-in-out;
}
.toggle:checked + .collapsible-toggle + .collapsible-content {
    max-height: 100vh;
}
.toggle:checked + .collapsible-toggle::before {
    transform: rotate(90deg) translateX(-3px);
}
.toggle:checked + .collapsible-toggle {
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
}
        </style>
    </head>
    <body>
        <main>
            
    <h1>Romano Lab @ <span style="color: #011F5B;">Penn</span></h1>
    
<p>Return to <a href="index.html">home</a></p>
<hr/>
<h2>Current lab members</h2>
<h3>Principal Investigator</h3>
<div class="person">
    
    <div class="headshot">
        <img class="headshot-img" src="./_includes/assets/img/headshot-500px-1.jpg"/>
    </div>
    
    <div class="bio">
        <h4>Joseph D. Romano, PhD</h4>
        <div class="titles">
            <p>Assistant Professor of Informatics</p>
            <p>Institute for Biomedical Informatics</p>
            <p>Center of Excellence in Environmental Toxicology</p>
            <p>Department of Biostatistics, Epidemiology, &amp; Informatics</p>
        </div>
        <p>
            <a href="http://jdr.bio">Personal website</a> | <a href="https://twitter.com/JDRomano2">Twitter</a> | <a href="https://www.linkedin.com/in/jdromano2/">LinkedIn</a>
        </p>
        
    </div>

</div>


        </main>
        <script>
            /**
 * graph.js
 * Copyright (c) 2022 by Joseph D. Romano
 * 
 * Simple routines for drawing random graphs
 */


// Global variables

const globals = {
    'nodeRadius': 4,
    'nodeSpacing': 25,
    'edgeWidth': 2,
    'edgeColor': '#808080'
};

const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d');

const colors = [
    '#e91e63',
    '#fa750f',
    '#ffeb3b',
    '#4caf50',
    '#02b3e4',
    '#c341d8'
]; 

/**
 * Retrieve a random sample of an array by performing the Fisher-Yates shuffle
 * and then taking a slice of the desired size.
 * 
 * See: https://stackoverflow.com/a/11935263/1730417
 * 
 * @param {Array} arr An array from which to draw samples
 * @param {Integer} n Number of samples to draw from `arr`
 */
function getRandomSample(arr, n) {
    let shuffled = arr.slice(0);
    let i = arr.length;
    let temp, idx;

    while (i--) {
        idx = Math.floor((i+1) * Math.random());
        temp = shuffled[idx];
        shuffled[idx] = shuffled[i];
        shuffled[i] = temp;
    }
    
    return shuffled.slice(0, n);
}


// Data structures

class Node {
    constructor(x, y) {
        this.x = x;
        this.y = y;

        this.left   = this.x - globals.nodeSpacing / 2 + globals.nodeRadius;
        this.top    = this.y - globals.nodeSpacing / 2 + globals.nodeRadius;
        this.right  = this.x + globals.nodeSpacing / 2 - globals.nodeRadius;
        this.bottom = this.y + globals.nodeSpacing / 2 - globals.nodeRadius;

        this.abs_x = this.left + (this.right - this.left) * Math.random();
        this.abs_y = this.top + (this.bottom - this.top) * Math.random();

        this.color = colors[Math.floor(Math.random() * colors.length)];
    }

    drawNode() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.abs_x, this.abs_y, globals.nodeRadius, 0, 2 * Math.PI);
        ctx.fill();
    }

}


class Edge {
    constructor(startNode, endNode) {
        this.startNode = startNode;
        this.endNode = endNode;

        this.x1 = this.startNode.abs_x;
        this.x2 = this.endNode.abs_x;

        this.y1 = this.startNode.abs_y;
        this.y2 = this.endNode.abs_y;
    }

    drawEdge() {
        ctx.globalAlpha = 1.0;
        ctx.strokeStyle = globals.edgeColor;
        ctx.edgeWidth = globals.edgeWidth;
        ctx.beginPath();
        ctx.moveTo(this.x1, this.y1);
        ctx.lineTo(this.x2, this.y2);
        ctx.stroke();
    }
}

class Graph {
    /**
     * 
     * @param {canvas} cnv <canvas> object where the graph will be drawn
     */
    constructor(cnv) {
        this.nodes = Array();
        this.edges = Array();

        this.canvas = cnv
        this.canvas_height = cnv.height;
        this.canvas_width = cnv.width;
        
    }

    /**
     * 
     * @param {Integer} canvas_x x-coordinate within the associated canvas
     * @param {Integer} canvas_y y-coordinate within the associated canvas
     */
    addNode(canvas_x, canvas_y) {
        this.nodes.push(new Node(canvas_x, canvas_y))
    }

    addRandomNodes(n_nodes) {
        let random_node_coords = Array();
        
        for(var i=0; i < n_nodes; i++) {
            random_node_coords.push([
                Math.random() * this.canvas_width,
                Math.random() * this.canvas_height
            ]);
        }

        random_node_coords.forEach(nc => {
            this.addNode(nc[0], nc[1])
        });
    }

    addEdge(startNodeIndex, endNodeIndex) {
        const startNode = this.nodes[startNodeIndex];
        const endNode = this.nodes[endNodeIndex];
        
        this.edges.push(new Edge(startNode, endNode));
    }

    addRandomEdges(n_edges) {
        let edges = Array();
        
        for(var i=0; i < n_edges; i++) {
            getRandomSample(this.nodes, 2);
        }
    }

    drawGraph() {
        // We draw the edges first, so their tips sit 'behind' the nodes
        this.edges.forEach(e => e.drawEdge());
        this.nodes.forEach(n => n.drawNode());
    }
}


// Drawing subroutines
function drawNodes(nodes) {
    nodes.forEach(n => n.drawNode());
}

function drawEdges(nodes, adjacency_list) {
    let edges = [];
    
    adjacency_list.forEach(al => {
        edges.push(new Edge(nodes[al[0]], nodes[al[1]]))
    });

    edges.forEach(e => e.drawEdge());
}

function drawGraph(coords, adjacencies) {
    // Draw nodes
    if (coords) {
        let nodes = Array();

        coords.forEach(n => {
            nodes.push(new Node(n[0], n[1]));
        });
        
        drawNodes(nodes);
        drawEdges(nodes, adjacencies);
                
    } else {
        // draw random nodes
        console.log("Shouldn't be printing this yet!!");
    }
}


// Draw a random graph
let node_coords = [
    [30, 85],
    [150, 60],
    [210, 100]
];
let adjacencies = [
    [0, 2],
    [0, 1]
];

let G = new Graph(canvas);

function start() {
    // drawGraph(node_coords, adjacencies);
    G.addRandomNodes(5);
    G.addRandomEdges(2);

    G.drawGraph();
}

window.setTimeout(start, 100);
        </script>
    </body>
    <footer>
        <div id="bottom-footer">
            <p><i>Copyright &copy; 2022 by Joseph D. Romano and the Romano Lab</i></p>
        </div>
    </footer>
</html>